# LTI-JACA

## Description

LTI-ATS-JACA is a cutting-edge Applicant Tracking System designed to streamline and optimize the recruitment process for organizations of all sizes. This comprehensive solution combines intuitive user interface with powerful automation features to help HR professionals and hiring managers efficiently manage their talent acquisition pipeline. LTI-ATS-JACA aims to reduce time-to-hire, improve candidate experience, and provide valuable insights to make data-driven hiring decisions.
Basic functionalities of an ATS, listed and described in order of priority:

1. Job Posting and Distribution:
   - Create and publish job listings across multiple platforms.
   - Integrate with job boards and career sites.
   - Manage internal job postings.

2. Resume Parsing and Candidate Profile :Creation
   - Automatically extract information from resumes.
   - Create standardized candidate profiles.
   - Enable keyword search and filtering.

3. Applicant Tracking and Workflow Management:
   - Track candidate progress through hiring stages.
   - Customize hiring workflows for different positions.
   - Automate status updates and notifications.

4. Communication Tools:
   - Send automated emails to candidates.
   - Schedule interviews and send reminders.
   - Facilitate internal communication between hiring team members.

5. Interview Management:
   - Schedule and track interviews.
   - Provide interview guides and scorecards.
   - Collect and organize feedback from interviewers.

6. Candidate Evaluation and Scoring:
   - Create customizable evaluation criteria.
   - Enable collaborative scoring and ranking.
   - Generate comparison reports for decision-making.

7. Reporting and Analytics:
   - Track key recruitment metrics (e.g., time-to-hire, source of hire).
   - Generate customizable reports.
   - Provide data-driven insights for process improvement.

8. Compliance and Equal Employment :Opportunity (EEO) Tracking
   - Ensure compliance with labor laws and regulations.
   - Track and report on diversity metrics.
   - Manage required documentation for audits.

9. Integration Capabilities:
   - Connect with HRIS, payroll, and onboarding systems.
   - Integrate with background check services.
   - Enable single sign-on (SSO) for seamless user experience.

10. Mobile Accessibility:
    - Provide mobile-friendly interface for candidates and hiring managers.
    - Enable on-the-go application reviews and approvals.
    - Facilitate mobile communication and notifications.

## Added Value
1. Improved Efficiency
   - Streamlined recruitment process
   - Reduced time-to-hire
   - Automation of repetitive tasks

2. Cost Reduction
   - Lower recruitment advertising costs
   - Decreased reliance on external recruiters
   - Optimized use of HR resources

3. Enhanced Candidate Experience
   - User-friendly application process
   - Timely communication and updates
   - Mobile accessibility for on-the-go applications

4. Better Quality of Hires
   - Standardized evaluation criteria
   - Data-driven decision making
   - Improved candidate matching through AI-powered screening

5. Increased Collaboration
   - Centralized communication for hiring teams
   - Easy sharing of candidate information and feedback
   - Improved alignment between HR and hiring managers

6. Compliance and Risk Mitigation
   - Ensure adherence to labor laws and regulations
   - Standardized processes to reduce bias
   - Proper documentation for potential audits

7. Data-Driven Insights
   - Comprehensive recruitment analytics
   - Identification of best-performing sourcing channels
   - Metrics to continuously improve hiring processes

8. Scalability
   - Ability to handle high-volume recruiting
   - Adaptable to company growth and changing needs
   - Support for multiple locations or departments

9. Improved Employer Branding
   - Professional and consistent candidate communication
   - Showcase company culture through customized career pages
   - Positive candidate experience leading to better company reviews

10. Time Savings
    - Faster resume screening and shortlisting
    - Automated interview scheduling
    - Quick generation of offer letters and contracts

11. Enhanced Talent Pool Management
    - Build and maintain a database of potential candidates
    - Easy retrieval of past applicants for new positions
    - Nurture relationships with passive candidates

12. Integration Capabilities
    - Seamless connection with existing HR systems
    - Unified data flow from recruitment to onboarding
    - Reduced manual data entry and potential errors

13. Customization and Flexibility
    - Tailored workflows for different positions or departments
    - Customizable evaluation forms and interview guides
    - Adaptable reporting to meet specific organizational needs

14. Improved Decision Making
    - Side-by-side candidate comparisons
    - Historical data to inform hiring strategies
    - Predictive analytics for future hiring needs

15. Global Recruiting Support
    - Multi-language capabilities
    - Compliance with international hiring regulations
    - Support for diverse hiring practices across regions

## Targets

1. Company Size:
   a) Small Businesses (1-50 employees)
   b) Mid-size Companies (51-500 employees)
   c) Large Enterprises (500+ employees)

2. Industry Sectors:
   a) Technology and IT
   b) Healthcare and Pharmaceuticals
   c) Financial Services and Banking
   d) Retail and E-commerce
   e) Manufacturing
   f) Education
   g) Professional Services (Consulting, Legal, etc.)
   h) Non-profit Organizations

3. Geographical Regions:
   a) North America
   b) Europe
   c) Asia-Pacific
   d) Latin America
   e) Middle East and Africa

4. Hiring Volume:
   a) Low-volume recruiters (1-10 hires per month)
   b) Medium-volume recruiters (11-50 hires per month)
   c) High-volume recruiters (50+ hires per month)

5. Organizational Structure:
   a) Centralized HR departments
   b) Decentralized hiring (department-led recruitment)
   c) Staffing and recruitment agencies

6. Technology Adoption Level:
   a) Early adopters (tech-savvy organizations)
   b) Mainstream users (average technology adoption)
   c) Late adopters (traditional or risk-averse organizations)

7. Specific Hiring Needs:
   a) High-skill technical positions
   b) Executive and leadership roles
   c) Entry-level and internship programs
   d) Seasonal or temporary workforce
   e) Remote and distributed teams

8. Budget Constraints:
   a) Cost-sensitive organizations
   b) Value-oriented buyers
   c) Premium feature seekers

9. Compliance Requirements:
   a) Highly regulated industries (e.g., government, healthcare)
   b) Companies with strict data privacy needs
   c) Organizations with specific diversity and inclusion goals

10. Current ATS Status:
    a) First-time ATS buyers
    b) Organizations looking to switch from existing ATS
    c) Companies seeking to upgrade or consolidate multiple systems

## Competitors

1. Workday Recruiting

   Strengths:
   - Comprehensive HR suite integration
   - Strong analytics and reporting capabilities
   - User-friendly interface

   Weaknesses:
   - Can be complex for smaller organizations
   - Higher price point
   - May have longer implementation times

2. Greenhouse

   Strengths:
   - Excellent user experience
   - Strong focus on promoting diversity in hiring
   - Extensive integration options

   Weaknesses:
   - Can be expensive for smaller companies
   - Some users report limitations in customization
   - May lack some advanced features for enterprise-level needs

3. Lever

   Strengths:
   - Modern, intuitive interface
   - Strong collaboration tools
   - Good candidate relationship management features

   Weaknesses:
   - Limited reporting capabilities compared to some competitors
   - May lack some features for very large enterprises
   - Pricing can be high for smaller organizations

4. Taleo (Oracle)

   Strengths:
   - Robust features for large enterprises
   - Strong compliance tools
   - Extensive customization options

   Weaknesses:
   - User interface often criticized as outdated
   - Can be complex to use and set up
   - May be overkill for smaller organizations

5. SmartRecruiters

   Strengths:
   - AI-powered candidate matching
   - Strong marketplace for third-party integrations
   - Good scalability for growing companies

   Weaknesses:
   - Some users report occasional performance issues
   - Advanced features may require higher-tier plans
   - Customer support responsiveness has been criticized

6. iCIMS

   Strengths:
   - Comprehensive recruitment marketing tools
   - Strong compliance features
   - Good for high-volume recruiting

   Weaknesses:
   - Interface can be less intuitive than some competitors
   - Implementation can be complex
   - Some users report issues with system speed

7. Jobvite

   Strengths:
   - Strong social recruiting features
   - Good candidate relationship management
   - User-friendly interface

   Weaknesses:
   - Reporting capabilities may be limited for some users
   - Some advanced features only available in higher-tier plans
   - Integration with some third-party tools can be challenging

## Competitive Advantages

1. Adaptive AI-Powered Matching:
   - Advanced AI that learns from each organization's hiring patterns.
   - Continuously improving candidate matching and ranking.

2. Seamless Scalability:
   - Easily adapts from small business to enterprise-level needs.
   - No need to switch systems as the company grows.

3. Intuitive Customization Engine:
   - User-friendly interface for creating custom workflows and forms.
   - No coding required for advanced customizations.

4. Rapid Implementation Program:
   - Streamlined setup process with intelligent data migration.
   - Get up and running in days, not months.

5. Unified Communication Hub:
   - Centralized platform for all recruitment communications.
   - Integrates email, messaging, and video interviews.

6. Compliance Assurance System:
   - Built-in compliance checks for various global regulations.
   - Automatic updates to stay current with changing laws.

7. Predictive Analytics Dashboard:
   - Forecast hiring needs based on historical data and market trends.
   - Provide actionable insights to improve recruitment strategies.

8. Candidate Experience Optimizer:
   - Personalized candidate portals with real-time status updates.
   - Automated feedback collection to continuously enhance the process.

9. Flexible Pricing Model:
   - Pay-per-use option for smaller organizations or seasonal hiring.
   - Customizable feature sets to avoid overpaying for unused tools.

10. Seamless Integration Ecosystem:
    - One-click integrations with popular HR tools and job boards.
    - Open API for easy custom integrations.

11. Mobile-First Design:
    - Fully functional mobile app for both recruiters and candidates.
    - Optimized for on-the-go hiring and applying.

12. Automated Bias Detection:
    - AI-powered tools to identify and mitigate unconscious bias in job descriptions and screening processes.
    - Promote diversity and inclusion throughout the hiring process.

13. Continuous Learning Platform:
    - Built-in tutorials and best practices updated in real-time.
    - Personalized system suggestions based on user behavior.

14. Global Talent Pool Network:
    - Shared, anonymized database of candidates across LTI-ATS-JACA users.
    - Respect privacy while expanding reach for hard-to-fill positions.

15. Proactive Customer Success Program:
    - Dedicated success managers for all account tiers.
    - Regular check-ins and personalized optimization recommendations.

## Lean Canvas Diagram

```mermaid
graph TD
  subgraph "Lean Canvas: LTI-ATS-JACA"
    A[Problem<br/>1. Inefficient hiring processes<br/>2. Poor candidate experience<br/>3. Lack of data-driven insights]
    B[Solution<br/>1. AI-powered matching<br/>2. Intuitive customization<br/>3. Predictive analytics]
    C[Unique Value Proposition<br/>Adaptive AI-driven ATS<br/>that scales seamlessly<br/>and ensures compliance]
    D[Unfair Advantage<br/>Proprietary AI algorithm<br/>Rapid implementation<br/>Global talent pool network]
    E[Customer Segments<br/>1. SMBs<br/>2. Large enterprises<br/>3. Staffing agencies]
    F[Key Metrics<br/>1. User adoption rate<br/>2. Time-to-hire reduction<br/>3. Customer satisfaction]
    G[Channels<br/>1. Direct sales<br/>2. Partner network<br/>3. Content marketing]
    H[Cost Structure<br/>1. Development & maintenance<br/>2. Sales & marketing<br/>3. Customer support]
    I[Revenue Streams<br/>1. Subscription model<br/>2. Pay-per-use pricing<br/>3. Premium features]
end
```

</details>

## Functional Requirements

1. User Management
   - User registration and authentication
   - Role-based access control (e.g., admin, recruiter, hiring manager)
   - Password reset and account recovery

2. Job Requisition Management
   - Create, edit, and delete job requisitions
   - Approval workflow for job postings
   - Job template creation and management

3. Candidate Management
   - Candidate profile creation and editing
   - Resume parsing and data extraction
   - Candidate search and filtering
   - Candidate status tracking and updates

4. Application Process
   - Online job application form creation
   - Document upload (resumes, cover letters, portfolios)
   - Application status tracking for candidates

5. Screening and Assessment
   - Customizable screening questions
   - Skills assessment integration
   - AI-powered candidate ranking and matching

6. Interview Management
   - Interview scheduling and calendar integration
   - Video interview capability
   - Interview feedback collection and scoring

7. Communication
   - Email templates and bulk emailing
   - In-app messaging system
   - Automated notifications and reminders

8. Reporting and Analytics
   - Standard and custom report generation
   - Real-time dashboard with key metrics
   - Data export functionality

9. Integration Capabilities
   - API for third-party integrations
   - Job board posting integration
   - HRIS and payroll system integration

10. Compliance and EEO
    - EEO data collection and reporting
    - Compliance checklist for job postings
    - Audit trail for all system actions

11. Offer Management
    - Offer letter generation and tracking
    - E-signature integration for offer acceptance
    - Offer approval workflow

12. Career Site Management
    - Customizable career site builder
    - Job search and filtering for candidates
    - Mobile-responsive design

## Non-Functional Requirements

1. Performance
   - Page load time under 2 seconds for 95% of requests
   - Support for at least 10,000 concurrent users
   - Ability to handle 1 million job applications per month

2. Scalability
   - Horizontal scaling to accommodate growing user base
   - Ability to add new features without major system overhaul

3. Availability
   - 99.9% uptime guarantee
   - Scheduled maintenance windows with minimal disruption

4. Security
   - Data encryption at rest and in transit (minimum AES-256)
   - Regular security audits and penetration testing
   - Multi-factor authentication support

5. Compliance
   - GDPR, CCPA, and other relevant data protection regulations compliance
   - SOC 2 Type II certification
   - Regular compliance updates to meet changing regulations

6. Usability
   - Intuitive user interface requiring minimal training
   - Accessibility compliance (WCAG 2.1 level AA)
   - Support for multiple languages and locales

7. Reliability
   - Automated backups with point-in-time recovery
   - Fault-tolerant architecture with no single point of failure

8. Compatibility
   - Cross-browser support (Chrome, Firefox, Safari, Edge)
   - Mobile responsiveness for all major functions

9. Data Integrity
   - Data validation to ensure accuracy and consistency
   - Audit logs for all data changes

10. Maintainability
    - Modular architecture for easy updates and maintenance
    - Comprehensive system documentation
    - Automated testing with minimum 80% code coverage

11. Disaster Recovery
    - Recovery Time Objective (RTO) of 4 hours
    - Recovery Point Objective (RPO) of 1 hour

12. Performance Monitoring
    - Real-time system health monitoring
    - Automated alerts for performance issues

13. Interoperability
    - Support for standard data exchange formats (JSON, XML)
    - OAuth 2.0 support for secure API access

14. Customization
    - Ability to customize workflows without code changes
    - User-defined fields and forms

15. Data Retention and Archiving
    - Configurable data retention policies
    - Secure data archiving and retrieval system

## Main Use Cases

### Must Have (Critical features for launch)

1. User Management
   - Basic user registration and authentication
   - Role-based access control

```mermaid
graph TD
    G((Admin)) --> B(Register User)
    G --> D(Manage Roles)
    H((User)) --> C(Authenticate User)
    H --> E(Reset Password)
```

Users can register accounts, login, and reset passwords. Administrators have additional capabilities to manage user roles and also need to login to access these functions.

2. Job Requisition Management
   - Create, edit, and post job requisitions
   - Basic approval workflow

```mermaid
graph TD
    G((Recruiter)) --> B(Create Job Requisition)
    G --> C(Edit Job Requisition)
    G --> D(Post Job Requisition)
    H((Hiring Manager)) --> E(Approve Job Requisition)
```

Recruiters can create, edit, and post job requisitions, while Hiring Managers can approve requisitions and also have the ability to edit them if necessary.

3. Candidate Management
   - Candidate profile creation
   - Resume parsing and data extraction
   - Basic candidate search and filtering

```mermaid
graph TD
    F((System)) --> C(Parse Resume)
    G((Recruiter)) --> B(Create Candidate Profile)
    G --> D(Search Candidates)
    G --> E(Filter Candidates)
    H((Candidate)) --> B
```

Recruiters can create candidate profiles, search, and filter candidates. The system automatically parses resumes when a candidate profile is created.

4. Application Process
   - Online job application form
   - Document upload (resumes, cover letters)

```mermaid
graph TD
    F((Candidate)) --> B(Submit Application)
    F --> C(Upload Documents)
    G((Recruiter)) --> D(Review Application)
```

Candidates can fill out application forms, upload documents, and submit applications. Once submitted, the system processes the application automatically.

5. Screening and Assessment
   - Basic screening questions
   - AI-powered candidate ranking

```mermaid
graph TD
    F((Recruiter)) --> B(Create Screening Questions)
    G((Candidate)) --> C(Answer Screening Questions)
    H((AI System)) --> D(Rank Candidates)
    F --> D
```

Recruiters set screening questions, candidates answer them, and the system automatically ranks candidates based on their responses.

6. Interview Management
   - Interview scheduling
   - Basic feedback collection

```mermaid
graph TD
    F((Recruiter)) --> B(Schedule Interview)
    G((Interviewer)) --> C(Conduct Interview)
    G --> D(Provide Feedback)
    H((Candidate)) --> C
```

Recruiters schedule interviews, while interviewers conduct interviews and provide feedback.

7. Communication
   - Email templates and notifications
   - Automated status updates

```mermaid
graph TD
    F((Recruiter)) --> B(Create Email Template)
    F --> C(Send Notification)
    F --> D(Update Application Status)
    G((Candidate)) --> C
```

Recruiters can create email templates and update application statuses. The system sends automated notifications, which are received by candidates.

8. Reporting and Analytics
   - Standard reports on key metrics
   - Basic dashboard

```mermaid
graph TD
    F((Recruiter)) --> B(Generate Standard Report)
    F --> C(View Dashboard)
    F --> D(Export Data)
    G((Hiring Manager)) --> C
```

Both recruiters and hiring managers can view dashboards, while recruiters can also generate standard reports and export data.

9. Compliance and EEO
   - EEO data collection
   - Basic compliance checklist

```mermaid
graph TD
    F((Candidate)) --> B(Collect EEO Data)
    G((Recruiter)) --> C(Generate EEO Report)
    G --> D(Verify Compliance Checklist)
```

The system collects EEO data from candidates, recruiters can generate EEO reports and verify job posting compliance.

10. Security and Data Protection
    - Data encryption
    - Compliance with basic data protection regulations

```mermaid
graph TD
    G((System)) --> B(Encrypt Data)
    H((Admin)) --> C(Manage User Permissions)
    J((Security Officer)) --> D(Perform Security Audit)
    J --> E(Implement Data Protection Policies)
    J --> F(Monitor System Access)
```

The system is responsible for encrypting data and implementing data protection policies. Admins manage user permissions and implement data protection policies. Security officers perform security audits and monitor system access. All users interact with the system, which applies these security measures to protect their data and actions.

### Should Have (Important features for competitive advantage)

1. Integration Capabilities
   - API for third-party integrations
   - Job board posting integration

2. Career Site Management
   - Basic customizable career site

3. Offer Management
   - Offer letter generation and tracking

4. Advanced Screening and Assessment
   - Skills assessment integration
   - More advanced AI matching algorithms

5. Video Interview Capability

6. Mobile-Responsive Design

7. Customizable Workflows

8. Advanced Search and Filtering Options

9. Candidate Status Tracking and Updates

10. Bulk Actions for Candidate Management

### Could Have (Desirable features to enhance the product)

1. Advanced Reporting and Analytics
   - Custom report generation
   - Predictive analytics

2. Talent Pool Management

3. Employee Referral Management

4. Advanced Career Site Builder

5. Automated Reference Checking

6. Social Media Integration for Candidate Sourcing

7. Customizable Onboarding Checklist

8. Candidate Relationship Management (CRM) Features

9. Advanced Compliance Tools
   - Global compliance support
   - Audit trail for all actions

10. AI-Powered Chatbot for Candidate Queries

### Won't Have (for initial release, may consider for future versions)

1. Full HRIS Integration

2. Payroll System Integration

3. Advanced Succession Planning Tools

4. Employee Performance Management

5. Learning Management System (LMS) Integration

6. Advanced Employer Branding Tools

7. Recruitment Marketing Automation

8. Vendor Management System for Staffing Agencies

9. Internal Mobility and Career Pathing Tools

10. AI-Powered Interview Scheduling and Optimization

## Data Model

### Diagram

```mermaid
erDiagram
    %% Job Service
    JOB {
        BIGSERIAL job_id PK
        VARCHAR(255) title
        TEXT description
        VARCHAR(50) status
        BIGINT created_by_user_id FK
        TIMESTAMP created_at
        TIMESTAMP updated_at
    }
    JOB_SCREENING_QUESTION {
        BIGSERIAL question_id PK
        BIGINT job_id FK
        TEXT question
        VARCHAR(50) question_type
    }

    %% Application Service
    CANDIDATE {
        BIGSERIAL candidate_id PK
        VARCHAR(100) first_name
        VARCHAR(100) last_name
        VARCHAR(255) email
        TEXT resume
        TIMESTAMP created_at
    }
    APPLICATION {
        BIGSERIAL application_id PK
        BIGINT job_id FK
        BIGINT candidate_id FK
        VARCHAR(50) status
        TIMESTAMP applied_at
    }
    EEO_DATA {
        BIGSERIAL eeo_id PK
        BIGINT candidate_id FK
        VARCHAR(50) gender
        VARCHAR(50) ethnicity
        BOOLEAN veteran_status
        BOOLEAN disability_status
    }

    %% Interview Service
    INTERVIEW {
        BIGSERIAL interview_id PK
        BIGINT application_id FK
        BIGINT interviewer_id FK
        TIMESTAMP scheduled_at
        VARCHAR(50) status
        TEXT feedback
    }

    %% User Service
    USER {
        BIGSERIAL user_id PK
        VARCHAR(100) username
        VARCHAR(255) email
        VARCHAR(255) password_hash
        VARCHAR(50) role
        TIMESTAMP created_at
        TIMESTAMP last_login
    }

    %% Relationships
    JOB ||--o{ JOB_SCREENING_QUESTION : "has"
    JOB ||--o{ APPLICATION : "receives"
    CANDIDATE ||--o{ APPLICATION : "submits"
    CANDIDATE ||--o{ EEO_DATA : "provides"
    APPLICATION ||--o{ INTERVIEW : "schedules"
    USER ||--o{ JOB : "creates"
    USER ||--o{ INTERVIEW : "conducts"
```

### Description

1. Job Service:
   - JOB: Represents job postings.
   - JOB_SCREENING_QUESTION: Stores screening questions for each job.

2. Application Service:
   - CANDIDATE: Stores information about job applicants.
   - APPLICATION: Represents a candidate's application for a specific job.
   - EEO_DATA: Contains Equal Employment Opportunity data for candidates.

3. Interview Service:
   - INTERVIEW: Stores interview details for applications.

4. User Service:
   - USER: Represents system users (recruiters, hiring managers, admins).

Key points about the design:

1. Primary Keys: Each table has a BIGSERIAL primary key, which auto-increments and ensures each record has a unique identifier.

2. Foreign Keys: Foreign keys are used to establish relationships between tables, even across different services. In a microservices architecture, these would be logical relations rather than actual foreign key constraints in the database.

3. Data Types: Appropriate PostgreSQL data types are used (e.g., VARCHAR for strings, TEXT for long text, TIMESTAMP for dates and times).

4. Normalization: The design follows normalization principles to reduce data redundancy.

5. Scalability: The use of BIGSERIAL for IDs allows for a large number of records.

6. Audit Fields: Created_at and updated_at fields are included where appropriate for auditing purposes.

7. Status Fields: Enum-like status fields are used to track the state of jobs, applications, and interviews.

### Inter-service Relationships

- The JOB table in the Job Service has a foreign key to the USER table in the User Service (created_by_user_id).
- The APPLICATION table in the Application Service has a foreign key to the JOB table in the Job Service.
- The INTERVIEW table in the Interview Service has foreign keys to the APPLICATION table in the Application Service and the USER table in the User Service.

## Architecture

### Tech Stack

1. Frontend: React.js with TypeScript
2. Backend: Node.js with Express.js
3. Database: PostgreSQL
4. Caching: Redis
5. Search Engine: Elasticsearch
6. Message Queue: RabbitMQ
7. Container Orchestration: Kubernetes
8. CI/CD: GitHub Actions
9. Monitoring: Prometheus and Grafana
10. Logging: ELK Stack (Elasticsearch, Logstash, Kibana)
11. API Gateway: Kong
12. Authentication: OAuth 2.0 with JSON Web Tokens (JWT)
13. Cloud Provider: AWS

### Diagram

```mermaid
graph TB
    subgraph "Client"
        A[React.js Frontend]
    end

    subgraph "API Gateway"
        B[Kong]
    end

    subgraph "Authentication"
        C[OAuth 2.0 / JWT]
    end

    subgraph "Microservices"
        subgraph "Job Service"
            D[Job Service]
            D1[(Job DB)]
        end
        subgraph "Application Service"
            E[Application Service]
            E1[(Application DB)]
        end
        subgraph "Interview Service"
            F[Interview Service]
            F1[(Interview DB)]
        end
        subgraph "User Service"
            G[User Service]
            G1[(User DB)]
        end
    end

    subgraph "Message Queue"
        H[RabbitMQ]
    end

    subgraph "Caching"
        J[(Redis)]
    end

    subgraph "Search Engine"
        K[Elasticsearch]
    end

    subgraph "Monitoring & Logging"
        L[Prometheus]
        M[Grafana]
        N[ELK Stack]
    end

    subgraph "CI/CD"
        O[GitHub Actions]
    end

    subgraph "Container Orchestration"
        P[Kubernetes]
    end

    subgraph "Cloud Provider"
        Q[AWS]
    end

    A -->|HTTPS| B
    B -->|Auth| C
    B -->|REST API| D
    B -->|REST API| E
    B -->|REST API| F
    B -->|REST API| G
    D <--> H
    E <--> H
    F <--> H
    G <--> H
    D <--> D1
    E <--> E1
    F <--> F1
    G <--> G1
    D --> J
    E --> J
    F --> J
    G --> J
    D --> K
    E --> K
    F --> K
    G --> K
    D --> L
    E --> L
    F --> L
    G --> L
    L --> M
    D --> N
    E --> N
    F --> N
    G --> N
    O --> P
    P --> Q
```

### Description

Client: The frontend is built using React.js with TypeScript, providing a responsive and type-safe user interface.
API Gateway: Kong serves as the API gateway, handling incoming requests, routing them to appropriate microservices, and managing cross-cutting concerns like rate limiting and authentication.
Authentication: OAuth 2.0 with JWT is used for secure authentication and authorization across the system.
Microservices: The backend is divided into four main microservices:

Job Service: Manages job postings and related operations.
Application Service: Handles job applications and candidate information.
Interview Service: Manages interview scheduling and feedback.
User Service: Handles user management and authentication.

Each microservice is built using Node.js with Express.js.
Message Queue: RabbitMQ is used for asynchronous communication between microservices, enabling event-driven architecture and improving system resilience.
Database: PostgreSQL serves as the primary database for storing structured data across all microservices.
Caching: Redis is used for caching frequently accessed data, reducing database load and improving response times.
Search Engine: Elasticsearch provides powerful full-text search capabilities, particularly useful for job and candidate searches.
Monitoring & Logging:

Prometheus collects metrics from all services.
Grafana visualizes the metrics collected by Prometheus.
ELK Stack (Elasticsearch, Logstash, Kibana) is used for centralized logging and log analysis.

CI/CD: GitHub Actions automates the build, test, and deployment processes.
Container Orchestration: Kubernetes manages the deployment, scaling, and operations of application containers across clusters of hosts.
Cloud Provider: The entire infrastructure is hosted on AWS, leveraging its scalable and reliable cloud services.

## C4

### Context

```mermaid
graph TB
    subgraph lb[LTI-ATS-JACA]
        ltiAtsJaca[Applicant Tracking System]
    end
    
    candidate[Candidate]
    recruiter[Recruiter]
    hiringManager[Hiring Manager]
    emailSystem[Email System]
    jobBoards[Job Boards]
    
    candidate -->|Submits applications, views job listings| ltiAtsJaca
    recruiter -->|Manages job postings, reviews applications, schedules interviews| ltiAtsJaca
    hiringManager -->|Reviews candidates, provides feedback| ltiAtsJaca
    ltiAtsJaca -->|Sends notifications| emailSystem
    ltiAtsJaca -->|Posts job listings| jobBoards
    
    class candidate,recruiter,hiringManager person
    class emailSystem,jobBoards external_system
    class lb system_boundary
    
    classDef person fill:#08427B
    classDef external_system fill:#999999
    classDef system_boundary fill:#ffffff,stroke:#444444,stroke-width:2px,stroke-dasharray: 5 5
```

### Container

```mermaid
graph TB
    subgraph lb[LTI-ATS-JACA]
        webApp[Web Application<br/>React, TypeScript]
        mobileApp[Mobile App<br/>React Native]
        apiGateway[API Gateway<br/>Kong]
        appServer[Application Server<br/>Node.js, Express]
        database[(Database<br/>PostgreSQL)]
        searchEngine[Search Engine<br/>Elasticsearch]
        cacheLayer[Cache<br/>Redis]
        messageQueue[Message Queue<br/>RabbitMQ]
    end
    
    candidate[Candidate]
    recruiter[Recruiter]
    hiringManager[Hiring Manager]
    emailSystem[Email System]
    jobBoards[Job Boards]
    
    candidate -->|Uses| webApp
    candidate -->|Uses| mobileApp
    recruiter -->|Uses| webApp
    hiringManager -->|Uses| webApp
    
    webApp -->|Makes API calls to| apiGateway
    mobileApp -->|Makes API calls to| apiGateway
    apiGateway -->|Routes requests to| appServer
    
    appServer -->|Reads from and writes to| database
    appServer -->|Reads from and writes to| searchEngine
    appServer -->|Reads from and writes to| cacheLayer
    appServer -->|Publishes messages to| messageQueue
    
    appServer -->|Sends emails using| emailSystem
    appServer -->|Posts jobs to| jobBoards
    
    class candidate,recruiter,hiringManager person
    class emailSystem,jobBoards external_system
    class lb system_boundary
    class webApp,mobileApp,apiGateway,appServer,database,searchEngine,cacheLayer,messageQueue container
    
    classDef person fill:#08427B
    classDef external_system fill:#999999
    classDef system_boundary fill:#ffffff,stroke:#444444,stroke-width:2px,stroke-dasharray: 5 5
    classDef container fill:#438DD5
```

### Component

#### Application Server

```mermaid
graph TB
    subgraph lb[Application Server]
        userController[User Controller<br/>Express.js]
        jobController[Job Controller<br/>Express.js]
        applicationController[Application Controller<br/>Express.js]
        interviewController[Interview Controller<br/>Express.js]
        authService[Auth Service<br/>Node.js]
        searchService[Search Service<br/>Node.js]
        emailService[Email Service<br/>Node.js]
        jobBoardService[Job Board Service<br/>Node.js]
    end
    
    apiGateway[API Gateway<br/>Kong]
    database[(Database<br/>PostgreSQL)]
    searchEngine[Search Engine<br/>Elasticsearch]
    cacheLayer[Cache<br/>Redis]
    messageQueue[Message Queue<br/>RabbitMQ]
    emailSystem[Email System]
    jobBoards[Job Boards]
    
    apiGateway -->|Routes requests to| userController
    apiGateway -->|Routes requests to| jobController
    apiGateway -->|Routes requests to| applicationController
    apiGateway -->|Routes requests to| interviewController
    
    userController --> authService
    jobController --> authService
    applicationController --> authService
    interviewController --> authService
    
    jobController --> searchService
    applicationController --> searchService
    
    userController --> emailService
    jobController --> emailService
    applicationController --> emailService
    interviewController --> emailService
    
    jobController --> jobBoardService
    
    authService -->|Reads from and writes to| database
    userController -->|Reads from and writes to| database
    jobController -->|Reads from and writes to| database
    applicationController -->|Reads from and writes to| database
    interviewController -->|Reads from and writes to| database
    
    searchService -->|Reads from and writes to| searchEngine
    authService -->|Reads from and writes to| cacheLayer
    emailService -->|Publishes messages to| messageQueue
    
    emailService -->|Sends emails using| emailSystem
    jobBoardService -->|Posts jobs to| jobBoards
    
    class apiGateway,database,searchEngine,cacheLayer,messageQueue,emailSystem,jobBoards external_component
    class lb system_boundary
    class userController,jobController,applicationController,interviewController,authService,searchService,emailService,jobBoardService component
    
    classDef external_component fill:#999999
    classDef system_boundary fill:#ffffff,stroke:#444444,stroke-width:2px,stroke-dasharray: 5 5
    classDef component fill:#85BBF0
```

### Code

#### Job Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[Job Controller]
    B -->|Query/Update| C[Job Service]
    C -->|CRUD Operations| D[Job Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant JC as JobController
    participant JS as JobService
    participant JR as JobRepository
    participant DB as Database

    C->>JC: POST /jobs (Create Job)
    JC->>JS: createJob(jobDTO)
    JS->>JR: save(job)
    JR->>DB: INSERT INTO jobs
    DB-->>JR: Job Created
    JR-->>JS: Job Object
    JS-->>JC: JobDTO
    JC-->>C: 201 Created (JobDTO)

    C->>JC: GET /jobs/{id} (Get Job)
    JC->>JS: getJob(id)
    JS->>JR: findById(id)
    JR->>DB: SELECT FROM jobs
    DB-->>JR: Job Data
    JR-->>JS: Job Object
    JS-->>JC: JobDTO
    JC-->>C: 200 OK (JobDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class JobController {
        -JobService jobService
        +createJob(JobDTO) : ResponseEntity
        +getJob(Long) : ResponseEntity
        +updateJob(Long, JobDTO) : ResponseEntity
        +deleteJob(Long) : ResponseEntity
        +listJobs(Pageable) : ResponseEntity
    }
    class JobService {
        -JobRepository jobRepository
        +createJob(JobDTO) : JobDTO
        +getJob(Long) : JobDTO
        +updateJob(Long, JobDTO) : JobDTO
        +deleteJob(Long) : void
        +listJobs(Pageable) : Page<JobDTO>
    }
    class JobRepository {
        +save(Job) : Job
        +findById(Long) : Optional<Job>
        +delete(Job) : void
        +findAll(Pageable) : Page<Job>
    }
    class Job {
        -Long id
        -String title
        -String description
        -JobStatus status
        -Date createdAt
        -Date updatedAt
    }
    class JobDTO {
        +Long id
        +String title
        +String description
        +JobStatus status
        +Date createdAt
        +Date updatedAt
    }

    JobController --> JobService
    JobService --> JobRepository
    JobRepository --> Job
    JobService --> JobDTO
```

#### Application Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[Application Controller]
    B -->|Query/Update| C[Application Service]
    C -->|CRUD Operations| D[Application Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant AC as ApplicationController
    participant AS as ApplicationService
    participant AR as ApplicationRepository
    participant DB as Database

    C->>AC: POST /applications (Submit Application)
    AC->>AS: submitApplication(applicationDTO)
    AS->>AR: save(application)
    AR->>DB: INSERT INTO applications
    DB-->>AR: Application Created
    AR-->>AS: Application Object
    AS-->>AC: ApplicationDTO
    AC-->>C: 201 Created (ApplicationDTO)

    C->>AC: GET /applications/{id} (Get Application)
    AC->>AS: getApplication(id)
    AS->>AR: findById(id)
    AR->>DB: SELECT FROM applications
    DB-->>AR: Application Data
    AR-->>AS: Application Object
    AS-->>AC: ApplicationDTO
    AC-->>C: 200 OK (ApplicationDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class ApplicationController {
        -ApplicationService applicationService
        +submitApplication(ApplicationDTO) : ResponseEntity
        +getApplication(Long) : ResponseEntity
        +updateApplication(Long, ApplicationDTO) : ResponseEntity
        +deleteApplication(Long) : ResponseEntity
        +listApplications(Pageable) : ResponseEntity
    }
    class ApplicationService {
        -ApplicationRepository applicationRepository
        +submitApplication(ApplicationDTO) : ApplicationDTO
        +getApplication(Long) : ApplicationDTO
        +updateApplication(Long, ApplicationDTO) : ApplicationDTO
        +deleteApplication(Long) : void
        +listApplications(Pageable) : Page<ApplicationDTO>
    }
    class ApplicationRepository {
        +save(Application) : Application
        +findById(Long) : Optional<Application>
        +delete(Application) : void
        +findAll(Pageable) : Page<Application>
    }
    class Application {
        -Long id
        -Long jobId
        -Long candidateId
        -ApplicationStatus status
        -Date appliedAt
    }
    class ApplicationDTO {
        +Long id
        +Long jobId
        +Long candidateId
        +ApplicationStatus status
        +Date appliedAt
    }

    ApplicationController --> ApplicationService
    ApplicationService --> ApplicationRepository
    ApplicationRepository --> Application
    ApplicationService --> ApplicationDTO
```

#### Interview Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[Interview Controller]
    B -->|Query/Update| C[Interview Service]
    C -->|CRUD Operations| D[Interview Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant IC as InterviewController
    participant IS as InterviewService
    participant IR as InterviewRepository
    participant DB as Database

    C->>IC: POST /interviews (Schedule Interview)
    IC->>IS: scheduleInterview(interviewDTO)
    IS->>IR: save(interview)
    IR->>DB: INSERT INTO interviews
    DB-->>IR: Interview Scheduled
    IR-->>IS: Interview Object
    IS-->>IC: InterviewDTO
    IC-->>C: 201 Created (InterviewDTO)

    C->>IC: GET /interviews/{id} (Get Interview)
    IC->>IS: getInterview(id)
    IS->>IR: findById(id)
    IR->>DB: SELECT FROM interviews
    DB-->>IR: Interview Data
    IR-->>IS: Interview Object
    IS-->>IC: InterviewDTO
    IC-->>C: 200 OK (InterviewDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class InterviewController {
        -InterviewService interviewService
        +scheduleInterview(InterviewDTO) : ResponseEntity
        +getInterview(Long) : ResponseEntity
        +updateInterview(Long, InterviewDTO) : ResponseEntity
        +cancelInterview(Long) : ResponseEntity
        +listInterviews(Pageable) : ResponseEntity
    }
    class InterviewService {
        -InterviewRepository interviewRepository
        +scheduleInterview(InterviewDTO) : InterviewDTO
        +getInterview(Long) : InterviewDTO
        +updateInterview(Long, InterviewDTO) : InterviewDTO
        +cancelInterview(Long) : void
        +listInterviews(Pageable) : Page<InterviewDTO>
    }
    class InterviewRepository {
        +save(Interview) : Interview
        +findById(Long) : Optional<Interview>
        +delete(Interview) : void
        +findAll(Pageable) : Page<Interview>
    }
    class Interview {
        -Long id
        -Long applicationId
        -Long interviewerId
        -Date scheduledAt
        -InterviewStatus status
        -String feedback
    }
    class InterviewDTO {
        +Long id
        +Long applicationId
        +Long interviewerId
        +Date scheduledAt
        +InterviewStatus status
        +String feedback
    }

    InterviewController --> InterviewService
    InterviewService --> InterviewRepository
    InterviewRepository --> Interview
    InterviewService --> InterviewDTO
```

#### User Controller

##### Interaction Diagram

```mermaid
graph TD
    A[Client] -->|HTTP Request| B[User Controller]
    B -->|Query/Update| C[User Service]
    C -->|CRUD Operations| D[User Repository]
    D -->|Database Operations| E[(Database)]
```

##### Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Client
    participant UC as UserController
    participant US as UserService
    participant UR as UserRepository
    participant DB as Database

    C->>UC: POST /users (Create User)
    UC->>US: createUser(userDTO)
    US->>UR: save(user)
    UR->>DB: INSERT INTO users
    DB-->>UR: User Created
    UR-->>US: User Object
    US-->>UC: UserDTO
    UC-->>C: 201 Created (UserDTO)

    C->>UC: GET /users/{id} (Get User)
    UC->>US: getUser(id)
    US->>UR: findById(id)
    UR->>DB: SELECT FROM users
    DB-->>UR: User Data
    UR-->>US: User Object
    US-->>UC: UserDTO
    UC-->>C: 200 OK (UserDTO)
```

##### Class Diagram

```mermaid
classDiagram
    class UserController {
        -UserService userService
        +createUser(UserDTO) : ResponseEntity
        +getUser(Long) : ResponseEntity
        +updateUser(Long, UserDTO) : ResponseEntity
        +deleteUser(Long) : ResponseEntity
        +listUsers(Pageable) : ResponseEntity
    }
    class UserService {
        -UserRepository userRepository
        +createUser(UserDTO) : UserDTO
        +getUser(Long) : UserDTO
        +updateUser(Long, UserDTO) : UserDTO
        +deleteUser(Long) : void
        +listUsers(Pageable) : Page<UserDTO>
    }
    class UserRepository {
        +save(User) : User
        +findById(Long) : Optional<User>
        +delete(User) : void
        +findAll(Pageable) : Page<User>
    }
    class User {
        -Long id
        -String username
        -String email
        -String passwordHash
        -UserRole role
        -Date createdAt
        -Date lastLogin
    }
    class UserDTO {
        +Long id
        +String username
        +String email
        +UserRole role
        +Date createdAt
        +Date lastLogin
    }

    UserController --> UserService
    UserService --> UserRepository
    UserRepository --> User
    UserService --> UserDTO
```
